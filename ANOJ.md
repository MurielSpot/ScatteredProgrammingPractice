# ANOJ算法笔记OJ
## 1002判断三角形
难度：1；时长：20分钟；ac：1次。

类型:数学问题,模拟.

## 1003删除结点
难度：2；时长：30多分钟；ac：4次才ac。

类型:静态链表.

注意事项：
1. 格式输出非常讲究，注意区别-1和五位id的情况。所给链表开头就有可能是-1！它的格式也要注意！因为格式问题改了好多次才ac。
测试点3应该是first为-1的情况。
测试点5会有数据addr不满5位数的情况，所以高位要补0。
测试点1会有first不满5位数的情况，如果按%05d输出，又没有讨论first==-1，则测试点3就会错。

## 1004收集数码晶体
难度：5（自己没做出来）；时长：1h以上；ac：3次。

类型:图,矩阵乘法.

注意事项:
1. 用邻接矩阵,邻接表都超时了.是408考研真题中的一道,用01矩阵的乘法做.
已知有01矩阵g,1表示两个顶点之间有路径,0表示没有,则g^m中的i行i列的非零元素,表示从i到j长度为m的路径条数,进行l次乘法后,即经过l座桥,获得l个晶体时,即为结果.

## 1005还原二叉树
难度：5（自己没做出来）；时长：30分钟；ac：1次。

类型:中序层序建树!!!

注意事项:
1. 一开始忘了输入n的值,结果没输值整个程序就结束了,因为n是全局变量,被初始化为0.还以为软件出了错.

思路：
1. 将层序遍历的值一个个插入到已建好的树中，因为层序遍历先输出上面一层再输下一层，所以插入建好的树的时候肯定插入在某个结点的空孩子上，不会出现这个要插入的结点的父亲还没有插入到树中的情况。
插入时判断在左子树还是在右子树，可以根据这个新结点和当前要插入的树的根结点在中序序列中的关系判断。
手动模拟一下就知道思路了,然后让程序按照手动模拟的顺序操作.遇到这种题不要但凭脑子想不出来就放弃.

## 1006调查黑暗气息（还没做出来，测试点9未通过）
难度：4；时长：70多分钟；ac：∞次。

类型:图的遍历,最短路径,etc.

注意事项:
1. 不能用dijkstra判断层次.

## 1007那些年我们一起考过的浙大
难度:1;时长:40分钟;ac:3次.

类型:排序吧,忘了.

注意事项:
1. 这么简单的题3次才ac...注意输出格式%013lld,不是%13lld,不能少了0!"准考证号必须按照输入原样输出"意思就是高位要补0,不是说要记录输入的先后次序.
2. 预编译有一些技巧可以让写代码速度变快.
3. 输入流重定向之后freopen("C:\\Users\\oakpa\\Desktop\\test.txt", "r", stdin);不用scanf,而用cin输入数据,也可以.<br/>
网上是这样说的:从底层上来说，C++ 的 cin 与 C语言的 scanf 都采用 stdin 作为输入源， 但cin和scanf 采用了不同的缓冲区，可以通过 ios 头文件里面的 sync_with_stdio () 函数设置缓冲区共享，使cin和scanf 共享缓冲区。C++也可以改变输入源，但这样很复杂。其实，C++对 stdin 进行了封装，用流和迭代器进行了转变了流的概念而已，而C的scanf直接操作 stdin而已

## 1008进击的二叉查找树
难度:2;时长:25分钟;ac:1次.

类型:判断两个树是否相同,树的遍历.

注意事项:
1. 判断两个树是否相同,可以把两个树的指针同时传入一个函数里,详见下面的same函数.
其它做法有分别输出两个树的中序序列,前/后/层序序列,比较这两对序列如果相同,则是相同的树.

## 10091009某计算器的超电磁炮
难度：5；时长：1h以上；ac：3次。

类型：栈的应用，中缀后缀表达式。

注意事项：
1. 没有。就是想说自己没做出来，要多做做。

思路：
1. 自己构造运算符优先级顺序表，然后用栈进行运算。
2. 简书，然后用后序表达式计算。

补充：
1. 逆波兰式（Reverse Polish notation，RPN，或逆波兰记法），也叫后缀表达式（将运算符写在操作数之后）.
2. （），（#，#），这里#表示栈底，之间无优先关系，因为表达式里不允许它们相继出现，所以在表达式没有错误的情况下，但当前符号等于）时，此时op栈的栈顶不会是（！
3. 操作数operand,运算符operator,界限符delimiter.

## 1010死亡拆分I
难度：2；时长：1h以上；ac：2次。

注意事项：
1. 注意数据范围，并不全是正数。
更好的做法：
用快拍的切分区间的做法，找pivot，直到找到正中间大小的数，把切分出两个全比pivot大和小的区间。此题数据较少，所以用sort可以，数据量很大时，需要用更优的做法，而不要用sort。《死亡拆分II》数据量比较大。
还有专门的函数可以实现找第k大元素的功能。nth_element 可以找到序列第 K 大并把序列分成小于跟大于两部分。

## 1011万妖穴
难度：2；时长：30分钟；ac：1次。

思路：
1. 老担心做错。vis数组存放洞穴是否被解除封印，need放小穴被解除封印还需要之前有几个洞穴被解除封印，g存放解除封印的前驱后继关系。
need在输入g的时候被初始化增加，在判断一个小穴被解除封印后更新减少，由于一个小穴被解除封印之后不会再被访问，所以不用担心need数组会被反复减少以致于出现负数的情况。

## 1012死亡拆分II
难度：4；时长：估计30分钟之内,没算时间；ac：第一种1次,第二种算法2次(其中第一次头文件少加了),第三种1次。

注意事项:
1. 元素有奇数个时,中位数可能时负数,所以不能直接用\[n/2,n)的和减去\[0,n/2)的和,要把中位数提出来,单独加上它的绝对值!
2. nth_element(A, A + n / 2, A + n);    // 寻找第n/2大的数，并进行切分.
3. swap函数需要iostream头文件.round需要cmath,rand和RAND_MAX需要cstdlib.
4. 写randSelect函数的时候,它的含义要确定好,不然可能出错!

做法:
1. 划分两个子集时,可以用nth_element函数.在algorithm头文件里.
2. 也可以用随机选择算法，期望时间复杂度为 O(n).不用先成函数的话,做起来很繁琐,我调试了2h多小时吧,才把后面的两种算法写完.🙄

测试数据:
<pre>7
8 7 3 1 5 4 6
//输出18
10
-10 -1 -4 -3 -7 -8 -6 -5 -2 -9
//输出25</pre>
